<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="style.css" rel="stylesheet" />
  </head>
  <body class="dark-m">
    <main>
      <!-- <button class="openOptions">Open options page</button>
      <p>test to see the font</p>
      <figure>
                            <div class="select-image-container">
                              <img class="main-image"  src="../options/assets/Loup's animated waves.PNG" ref="mainImage" />
                              <div class="select-image" >
                                <button class="add-image-btn select-image-btn"></button>
                              </div>
                            </div>
                            <div class="fade-text">
                              <figcaption>test</figcaption>
                              <div>
                          </figure> -->
      <div id="app" class="wrapper" v-cloak>
        <!-- <header>
          <h1>Frame It!</h1>
        </header> -->
        <div class="image-container" :class="borderNone">
          <!-- <img class="main-image" v-if="isValid" :src="imageURL" alt="" /> -->
          <!-- <div class="add-image" title="add an image" v-if="!isValid"> -->
          <!-- Hides the UI ones a valid image has been given -->
          <!-- <button
              @click="addImageActive = !addImageActive"
              class="add-image-btn"
            ></button> -->
          <!-- <input type="file" class="image-upload" /> -->
          <!-- <p class="add-image-para">
              To add an image, paste it's URL in the text field
            </p> -->
          <!-- <input
              type="text"
              name=""
              id=""
              class="add-image-url"
              placeholder="Image URL"
              v-if="addImageActive"
              v-model="imageURL"
              ref="imageInput"
            /> -->
          <add-image
            :allimages="allimages"
            :border="borderNone"
            :imagecounter="imagecounter"
            @newborder="(value) => borderNone = value"
            @newimage=""
            @removeimage="removeImage"
            @changeimage="changeImage"
            @rerendercomponent="rerenderComponent"
            @refreshstorage="loadFromStorage"
            @resetstorage="(value) => imagecounter = []"
            :key="componentKey"
          />
          <!-- </div> -->
          <!-- <add-image /> -->
        </div>
        <!-- <p class="warn-para" v-if="warnText">{{warnText}}</p> -->
        <image-gallery
          @removeimage="removeImage"
          @changeimage="changeImage"
          @newimage=""
          :cart="cart"
          :allimages="allimages"
          :imagecounter="imagecounter"
        />
        <!-- <div class="add-image" v-if="isValid">
        </div> -->
        <!-- <section class="image-gallery">
          <add-image :images="images" />
        </section> -->
      </div>
    </main>
    <script defer src="script.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script>
      let id = 1;
      let imageStorage;
      let counter = 0;
      let updatedImageCounter = [];
      let app = Vue.createApp({
        data() {
          return {
            // addImageActive: false,
            // imageURL: undefined,
            // isValid: undefined,
            // warnText: undefined,
            cart: {
              carrot: "carrot",
            },
            allimages: [
              {
                id: "undefined",
                imageURL: undefined,
                imageDescr: undefined,
                mainImage: false,
              },
            ],
            borderNone: undefined,
            imagecounter: [],
            componentKey: 1,
            // images: [
            //   {
            //     imageURL: "test",
            //     mainImage: false,
            //   },
            // ],
          };
        },
        //   };
        // },
        methods: {
          removeImage(index) {
            this.allimages.forEach((image, imgIndex, array) => {
              if (image.id === index) {
                /*if a given image in the array has the same ID as that of the one we want to remove, run this code*/
                array.splice(imgIndex, 1);

                // updatedImageCounter.splice(image.id, 1);
                // localStorage.setItem(
                //   "storedImageCounter",
                //   JSON.stringify(updatedImageCounter)
                // );

                // console.log(image.id, image.imageDescr);
                // console.log("Image was deleted" + updatedImageCounter);
              }
            });
            localStorage.setItem(
              "imageStorage",
              JSON.stringify(this.allimages) //look into this
            );
          },
          changeImage({ imageId, description, url }) {
            this.allimages.forEach((image, imgIndex, array) => {
              if (image.id === imageId) {
                //find the image inside the array and assign it the new description
                image.imageDescr = description;
                if (url) {
                  //when the main image gets deleted
                  image.imageUrl = url;
                  localStorage.setItem(
                    "imageStorage",
                    JSON.stringify(this.allimages)
                  ); //is this needed?
                }
                localStorage.setItem(
                  "imageStorage",
                  JSON.stringify(this.allimages)
                );
              }
            });
          },
          rerenderComponent() {
            this.componentKey++;
            localStorage.storedComponentKey = this.componentKey;
          },
          loadFromStorage() {
            imageStorage = localStorage.getItem("imageStorage");
            imageStorage = JSON.parse(imageStorage);
            this.allimages = imageStorage;
            counter = this.allimages.length;
            for (let i = 1; i < counter; i++) {
              //previously 1, then 0
              this.imagecounter.push(i);
              console.log(`BEST BELIEVE ${this.imagecounter}`);
            }
            // this.allimages.forEach((image, index) => {
            //   if (index !== 0) this.imagecounter.push(image.id);
            // });
            // updatedImageCounter = localStorage.getItem("storedImageCounter");
            // updatedImageCounter = JSON.parse(updatedImageCounter);
            // this.imagecounter = updatedImageCounter;
            localStorage.setItem("imagecounter", counter);
            localStorage.setItem(
              "totalImages",
              JSON.stringify(this.imagecounter)
            );
            // if (localStorage.storedComponentKey) {
            //   this.componentKey = localStorage.getItem("storedComponentKey");
            //   this.componentKey = JSON.parse(this.componentKey);
            //   // this.componentKey = 1;
            //   console.log("COMPONENT KEY");
            // }

            console.log(this.imagecounter.length);
            console.log("Storage was reloaded");
          },
        },
        created() {
          if (localStorage.imageStorage) {
            this.loadFromStorage();
          }

          // if (localStorage.imagecounter && localStorage.totalImages) {
          //   counter = localStorage.getItem("imagecounter");
          //   this.imagecounter = localStorage.getItem("totalImages");
          //   this.imagecounter = JSON.parse(this.imagecounter);
          // }
        },
        // watch: {
        //   imageURL() {
        //     //checks whether the url given is valid every time the imageURL property changes
        //     if (this.imageURL.match(/\.(jpeg|jpg|gif|png|svg)$/) != null) {
        //       this.isValid = true;
        //       this.warnText = null;
        //     } else {
        //       this.isValid = false;
        //       this.warnText =
        //         "This is not a valid image URL. Please make sure you entered the right link.";
        //     }
        //   },
        // },
      });

      app.component("add-image", {
        template: `
                    <div class="outer-image-wrapper" v-if="!imageRemoved" :style="{display: initialLoad}" ref="outerImageWrapper">
                      <div class="image-wrapper" v-for="(image, i) in images" :key="image.id" :allimages="allimages" v-on:mouseover="showBtn" v-on:mouseleave="hideBtn"
                      >
                        <Transition name="btn-fade">
                          <div class="btn-container" :class="btnActive" v-if="showImage" >
                            <button class="delete-btn img-btn" @click="deleteImage" @focus="showBtn" title="delete image"><svg  width="30" height="30" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M1.5 84V43C1.5 36.6487 6.64873 31.5 13 31.5H51C57.3513 31.5 62.5 36.6487 62.5 43V84C62.5 90.3513 57.3513 95.5 51 95.5H13C6.64873 95.5 1.5 90.3513 1.5 84Z" fill="#C96060" stroke="#C96060" stroke-width="3"/>
              <path d="M12 24C35.4285 -5.25 53 24 53 24" stroke="#C96060" stroke-width="3"/>
              <path d="M0 36C0 33.7909 1.79086 32 4 32H60C62.2091 32 64 33.7909 64 36V41C64 43.2091 62.2091 45 60 45H4C1.79086 45 0 43.2091 0 41V36Z" fill="#C96060"/>
              <path d="M0 36C0 33.7909 1.79086 32 4 32H60C62.2091 32 64 33.7909 64 36V41C64 43.2091 62.2091 45 60 45H4C1.79086 45 0 43.2091 0 41V36Z" stroke="white"/>
              <path d="M32.5 39.5C39.6434 39.5 46.1676 38.6503 50.9545 37.2423C53.3381 36.5413 55.3763 35.6774 56.8524 34.6509C58.2845 33.6551 59.5 32.2765 59.5 30.5C59.5 28.7235 58.2845 27.3449 56.8524 26.3491C55.3763 25.3226 53.3381 24.4587 50.9545 23.7577C46.1676 22.3497 39.6434 21.5 32.5 21.5C25.3566 21.5 18.8324 22.3497 14.0455 23.7577C11.6619 24.4587 9.62373 25.3226 8.14755 26.3491C6.71552 27.3449 5.5 28.7235 5.5 30.5C5.5 32.2765 6.71552 33.6551 8.14755 34.6509C9.62373 35.6774 11.6619 36.5413 14.0455 37.2423C18.8324 38.6503 25.3566 39.5 32.5 39.5Z" fill="#C96060" stroke="white" stroke-width="3"/>
              <path d="M32.5 19C35.4738 19 38.2541 18.1787 40.3469 16.7468C42.4301 15.3215 44 13.1475 44 10.5C44 7.85245 42.4301 5.67853 40.3469 4.25319C38.2541 2.82129 35.4738 2 32.5 2C29.5262 2 26.7459 2.82129 24.6531 4.25319C22.5699 5.67853 21 7.85245 21 10.5C21 13.1475 22.5699 15.3215 24.6531 16.7468C26.7459 18.1787 29.5262 19 32.5 19Z" fill="#C96060" stroke="white" stroke-width="4"/>
              <rect width="7.61585" height="45.6951" rx="3.80793" transform="matrix(0.669542 -0.742774 0.669542 0.742774 14 54.6569)" fill="white"/>
              <rect width="7.61585" height="45.6951" rx="3.80793" transform="matrix(0.669542 0.742774 -0.669542 0.742774 45.0171 49)" fill="white"/>
              <path d="M1.5 84V43C1.5 36.6487 6.64873 31.5 13 31.5H51C57.3513 31.5 62.5 36.6487 62.5 43V84C62.5 90.3513 57.3513 95.5 51 95.5H13C6.64873 95.5 1.5 90.3513 1.5 84Z" fill="#C96060" stroke="#C96060" stroke-width="3"/>
              <path d="M12 24C35.4285 -5.25 53 24 53 24" stroke="#C96060" stroke-width="3"/>
              <path d="M0 36C0 33.7909 1.79086 32 4 32H60C62.2091 32 64 33.7909 64 36V41C64 43.2091 62.2091 45 60 45H4C1.79086 45 0 43.2091 0 41V36Z" fill="#C96060"/>
              <path d="M32.5 39.5C39.6434 39.5 46.1676 38.6503 50.9545 37.2423C53.3381 36.5413 55.3763 35.6774 56.8524 34.6509C58.2845 33.6551 59.5 32.2765 59.5 30.5C59.5 28.7235 58.2845 27.3449 56.8524 26.3491C55.3763 25.3226 53.3381 24.4587 50.9545 23.7577C46.1676 22.3497 39.6434 21.5 32.5 21.5C25.3566 21.5 18.8324 22.3497 14.0455 23.7577C11.6619 24.4587 9.62373 25.3226 8.14755 26.3491C6.71552 27.3449 5.5 28.7235 5.5 30.5C5.5 32.2765 6.71552 33.6551 8.14755 34.6509C9.62373 35.6774 11.6619 36.5413 14.0455 37.2423C18.8324 38.6503 25.3566 39.5 32.5 39.5Z" fill="#C96060" stroke="white" stroke-width="3"/>
              <path d="M32.5 19C35.4738 19 38.2541 18.1787 40.3469 16.7468C42.4301 15.3215 44 13.1475 44 10.5C44 7.85245 42.4301 5.67853 40.3469 4.25319C38.2541 2.82129 35.4738 2 32.5 2C29.5262 2 26.7459 2.82129 24.6531 4.25319C22.5699 5.67853 21 7.85245 21 10.5C21 13.1475 22.5699 15.3215 24.6531 16.7468C26.7459 18.1787 29.5262 19 32.5 19Z" fill="#C96060" stroke="white" stroke-width="4"/>
              <rect width="7.61585" height="45.6951" rx="3.80793" transform="matrix(0.669542 -0.742774 0.669542 0.742774 14 54.6569)" fill="white"/>
              <rect width="7.61585" height="45.6951" rx="3.80793" transform="matrix(0.669542 0.742774 -0.669542 0.742774 45.0171 49)" fill="white"/>
              </svg>
              </button>
                            <button class="edit-btn img-btn" title="edit image" @click="editImage" ref="editBtn"><svg width="25" height="25" viewBox="0 0 87 87" fill="none" xmlns="http://www.w3.org/2000/svg">
      <rect x="2" y="7" width="78" height="78" rx="11" fill="white" stroke="#3B527F" stroke-width="4"/>
      <path d="M19.6724 42.9435L9.87239 74.2891C9.15006 76.5994 11.3206 78.7699 13.6309 78.0476L44.9765 68.2476C47.1285 67.5748 47.797 64.8573 46.2026 63.263L24.657 41.7173C23.0626 40.123 20.3452 40.7914 19.6724 42.9435Z" fill="white" stroke="#456093" stroke-width="4"/>
      <ellipse cx="12.6259" cy="74.5874" rx="4" ry="5.5" transform="rotate(45 12.6259 74.5874)" fill="#456093"/>
      <rect x="41.2637" y="45.2424" width="2" height="39" transform="rotate(45 41.2637 45.2424)" fill="#456093" stroke="#456093"/>
      <path d="M36.314 52.3135L37.0215 53.021C41.7935 67.3389 24.2936 65.749 17.9296 72.1129L17.2221 71.4054L36.314 52.3135Z" fill="#456093"/>
      <rect x="66.9858" y="0.570528" width="28" height="51" rx="14" transform="rotate(45 66.9858 0.570528)" fill="white" stroke="#3B527F" stroke-width="2"/>
      <path d="M69.4606 17.8946C72.0951 20.5292 74.937 22.5534 77.4475 23.6692C78.6979 24.2249 79.9411 24.5889 81.0794 24.643C82.2184 24.697 83.42 24.4413 84.3098 23.5515C85.1996 22.6617 85.4553 21.4601 85.4013 20.3211C85.3472 19.1827 84.9832 17.9396 84.4275 16.6892C83.3117 14.1787 81.2875 11.3368 78.653 8.70225C76.0184 6.0677 73.1765 4.04352 70.666 2.92773C69.4156 2.37201 68.1725 2.008 67.0341 1.95394C65.8951 1.89986 64.6935 2.1556 63.8037 3.0454C62.9139 3.9352 62.6582 5.13683 62.7123 6.27578C62.7663 7.41415 63.1303 8.65729 63.686 9.90766C64.8018 12.4182 66.826 15.2601 69.4606 17.8946Z" fill="white" stroke="#3B527F" stroke-width="3"/>
      <rect x="66.2788" y="32.3903" width="5" height="24" rx="2.5" transform="rotate(45 66.2788 32.3903)" fill="#456093"/>
      <rect x="59.2075" y="30.9761" width="7" height="22" rx="3" transform="rotate(45 59.2075 30.9761)" fill="#4497A9"/>
      <rect x="52.8438" y="20.3695" width="5" height="15" rx="2.5" transform="rotate(45 52.8438 20.3695)" fill="#B4D3DA"/>
      <rect x="71.2285" y="18.9553" width="4" height="11" rx="2" transform="rotate(45 71.2285 18.9553)" fill="#B5B4DA"/>
      <rect x="59.2075" y="30.9761" width="4" height="17" rx="2" transform="rotate(45 59.2075 30.9761)" fill="#4497A9"/>
      <rect x="64.8643" y="22.4908" width="3" height="17" rx="1.5" transform="rotate(45 64.8643 22.4908)" fill="#97C5D0"/>
      <rect x="64.8643" y="22.4908" width="3" height="17" rx="1.5" transform="rotate(45 64.8643 22.4908)" fill="#97C5D0"/>
      <rect x="64.8643" y="22.4908" width="3" height="17" rx="1.5" transform="rotate(45 64.8643 22.4908)" fill="#97C5D0"/>
      <rect x="64.8643" y="18.2482" width="4" height="17" rx="2" transform="rotate(45 64.8643 18.2482)" fill="#C2D2EA"/>
      <rect x="62.0361" y="28.1477" width="7" height="9" rx="3.5" transform="rotate(45 62.0361 28.1477)" fill="#CBDDF8"/>
      <rect x="60.6216" y="8.34869" width="5" height="24" rx="2.5" transform="rotate(45 60.6216 8.34869)" fill="#4497A9"/>
      <rect x="59.2075" y="6.93448" width="2" height="17" rx="1" transform="rotate(45 59.2075 6.93448)" fill="white"/>
      <rect width="4.97792" height="15.3798" transform="matrix(0.709479 0.704727 -0.694426 0.719565 82.2051 26.6672)" fill="white"/>
      </svg>
      </button>
                          </div>
                        </Transition>
                        <Transition name="fade">
                          <figure v-if="showImage" tabindex="0">
                            <div class="select-image-container">
                              <img class="main-image"  :src="image.imageURL" :alt="image.imageDescr" ref="mainImage" />
                              <div class="select-image" v-if="image.mainImage === false" :class="btnActive" >
                                <button class="add-image-btn select-image-btn" title="select as main image" @click="selectImage"></button>
                              </div>
                            </div>
                            <div class="fade-text">
                              <figcaption v-if="!editing" @dblclick="editImage">{{image.imageDescr}}</figcaption>
                              <!--<input v-show="editing" class="edit-img edit-url" type="text" v-model="image.imageURL" ref="editUrl"/>-->
                              <input v-show="editing" @keyup.enter="editImage" class="edit-img" type="text" v-model="image.imageDescr" ref="editDescr"/>
                              <!--<input v-show="editing" class="edit-img-border" type="color"/>-->
                            </div>
                          </figure>
                        </Transition>
                        <div class="add-image" :class="imageReady" v-if="!showImage" >
                            <!-- Hides the UI ones a valid image has been given -->
                            <form @submit.prevent="" class="add-image-form" novalidate autocomplete="off">
                              <button
                                @click="addImage"
                                class="add-image-btn" title="add an image"
                              ></button>
                              <Transition name="btn-fade">
                                <div class="label-container" v-if="addImageActive" >
                                  <label for="URL" class="add-image-label">Image URL</label>
                                  <input
                                    type="url"
                                    name="Image URL"
                                    id="URL"
                                    class="add-image-url"
                                    placeholder="https://cdn.wa.H's_Envelope.jpg"
                                    v-model="image.imageURL"
                                    ref="input"
                                    required="true"
                                  />
                                  <label for="descr" class="add-image-label">Description</label>
                                  <input
                                    type="text"
                                    name="Image description"
                                    id="descr"
                                    class="add-image-url"
                                    ref="inputDescr"
                                    placeholder="Hayley's envelope"
                                    v-model="image.imageDescr"
                                    required="true"
                                  />
                                  <p class="warn-para" v-if="warnText">{{warnText}}</p>
                                </div>
                              </Transition>
                            </form>
                            <!--<p class="add-image-para" v-if="addImageActive && !image.imageURL">
                              To add an image, paste it's URL in the text field
                            </p>-->
                            <!--<p v-if="showImage">{{image.imageDescr}}</p>-->
                          </div>
                        </div>
                      </div>`,
        props: ["allimages", "border", "imagecounter", "componentKey"],
        emits: [
          "newborder",
          "newimage",
          "removeimage",
          "changeimage",
          "rerendercomponent",
          "refreshstorage",
          "resetstorage",
        ],
        // emits: ["addImage"],
        data() {
          return {
            addImageActive: false,
            // imageURL: undefined,
            isValid: undefined,
            toShow: undefined,
            showImage: undefined,
            imageReady: undefined,
            imageRemoved: false,
            imageExists: undefined,
            removeReady: undefined,
            initialLoad: "block",
            latestImage: undefined,
            editing: false,
            btnActive: undefined,
            warnText: undefined,
            validUrl: undefined,
            // newImage: {
            //   url: undefined,
            //   descr: undefined,
            // },
            images: [
              {
                id: id++,
                imageURL: undefined,
                imageDescr: undefined,
                mainImage: false,
              },
            ],
          };
        },
        created() {
          if (localStorage.imageStorage) {
            this.allimages.forEach((image, imgIndex, array) => {
              for (imageLocal of this.images)
                if (image.id == imageLocal.id) {
                  imageLocal.imageURL = image.imageUrl;
                  imageLocal.imageDescr = image.imageDescr;
                  imageLocal.mainImage = image.mainImage;
                  this.initialLoad = "none";

                  //waiting for the images to load
                  const loadImage = (src) =>
                    new Promise((resolve, reject) => {
                      const img = new Image();
                      img.onload = () => resolve(img);
                      img.onerror = reject;
                      img.src = src;
                    });
                  loadImage(imageLocal.imageURL).then((image) => {
                    console.log("image loaded");
                    this.imageExists = true;
                    this.toShow = true;
                    this.showImage = true;
                    this.$emit("newborder", "has-image");
                    this.initialLoad = "block";
                  });
                  // this.imageExists = true;
                  // this.toShow = true;
                  // this.showImage = true;
                  // this.$emit("newborder", "has-image");
                }
            });
          }
          // this.initialLoad = "block";
        },
        methods: {
          addImage() {
            if (!this.addImageActive) {
              //open the menu in case it is closed
              this.addImageActive = !this.addImageActive;
            } else if (
              (this.addImageActive &&
                !this.toShow &&
                this.images[0].imageDescr === undefined) ||
              this.images[0].imageDescr === ""
            ) {
              if (this.isValid) {
                this.warnText = "Please enter a description";
                if (
                  this.$refs.input[0].classList.contains("add-image-url-error")
                ) {
                  this.$refs.input[0].classList.remove("add-image-url-error");
                } else {
                  this.$refs.inputDescr[0].classList.toggle(
                    "add-image-url-error"
                  );
                }
              } else {
                this.warnText = "Please enter a valid URL and description";
                this.$refs.input[0].classList.add("add-image-url-error");
                this.$refs.inputDescr[0].classList.add("add-image-url-error");
              }
            } else if (this.toShow) {
              //once it is open, let them add the image if they have filled out the input fields (through the handler function of the watcher)
              // this.images.push({
              //   imageURL: this.newImage.url,
              //   imageDescr: this.newImage.descr,
              //   mainImage: false,
              // });

              // this.allimages.push({
              //   imageURL: "this.newImage.url",
              //   imageDescr: "this.newImage.descr",
              //   mainImage: false,
              // });

              if (this.allimages.length < 2) {
                for (image of this.images) {
                  this.allimages.push({
                    id: image.id,
                    imageUrl: image.imageURL,
                    imageDescr: image.imageDescr,
                    mainImage: true,
                  });
                  image.mainImage = true;
                }
              } else {
                for (image of this.images) {
                  this.allimages.push({
                    id: image.id,
                    imageUrl: image.imageURL,
                    imageDescr: image.imageDescr,
                    mainImage: false,
                  });
                } //now I have to emit them to the parent so it can actually store all the images. Each image has it's own image object with all the related data, and the prop for all the images from the app. In the above code I push a new image object to the prop, but not the parent. If I emit it I should be able to collect the info of all the images in the parent
              }

              this.$emit("newimage", this.images);
              //UPDATE (12/10/22): This doesn't do anything, because it seems that you can add to an array without the need of an emit event. Maybe I am not mutating the prop, but simply adding to it?

              this.showImage = !this.showImage;

              //Again, waiting for the image so it doesn't render as it slides in.
              //Update: Not using it because of issues when it loads in. The next add button appears too soon perhaps.
              // const loadImage = (src) =>
              //   new Promise((resolve, reject) => {
              //     const img = new Image();
              //     img.onload = () => resolve(img);
              //     img.onerror = reject;
              //     img.src = src;
              //   });
              // loadImage(this.images[0].imageURL).then((image) => {
              //   this.showImage = !this.showImage;
              //   this.$emit("newborder", "has-image");
              // });

              localStorage.setItem(
                "imageStorage",
                JSON.stringify(this.allimages)
              );

              counter++;
              // counter = this.images[0].id;
              // console.log(`Counter = ${counter}`);
              this.imagecounter.push(counter);
              // this.imagecounter.push(this.images[0].id);
              // let lastIndex = this.allimages.length - 1;
              // this.imagecounter.push(lastIndex);
              // console.log(counter, this.imagecounter.length);
              // updatedImageCounter.push(lastIndex);
              // localStorage.setItem(
              //   "storedImageCounter",
              //   JSON.stringify(updatedImageCounter)
              // );

              localStorage.setItem("imagecounter", counter);
              localStorage.setItem(
                "totalImages",
                JSON.stringify(this.imagecounter)
              );
              // for (image of this.images) {
              //   image.imageURL = null;
              //   image.imageDescr = null;
              // }
              this.$emit("newborder", "has-image"); //lowercase because the v-on event doeesn't seem to be accepting other characters for event names
              // addImage();
            }
          },
          deleteImage() {
            // console.log(
            //   this.images[0].mainImage === true && this.allimages.length >= 2
            //     ? "YES"
            //     : "NO"
            // );
            // if (
            //   this.images[0].mainImage === true &&
            //   this.allimages.length <= 2
            // ) {
            //   console.log("This was the main image");
            //   // window.location.reload();
            //   this.images[0].imageURL = "";
            //   this.images[0].imageDescr = "";
            //   // this.addImageActive = false;
            //   // this.hasImage = false;
            //   // this.showImage = false;
            //   // this.warnText = null;
            //   // this.isValid = false;
            //   // this.imageReady = false;
            //   // this.btnActive = false;
            // }
            if (
              this.images[0].mainImage === true &&
              this.allimages.length > 2 //in case more images exist
            ) {
              //This way only the latest image gets added, and not any image that has a higher ID than the current one. Before all of them would get mentioned and deleted on refresh.
              // let latestImage = undefined;
              let i = 0;
              for (i = 0; i < this.allimages.length; i++) {
                this.latestImage = this.allimages[i];
                console.log("The highest one:" + this.latestImage.id);
              }
              // if (this.latestImage.id > this.images[0].id) {
              //   i--;
              //   this.latestImage = this.allimages[i];
              // } //this doesn't seem neccessary as it would never happen. The latest image always has a higher ID.

              this.images[0].imageURL = this.latestImage.imageUrl;
              this.images[0].imageDescr = this.latestImage.imageDescr;
              console.log(this.images[0]);

              //removing the latest image
              this.$emit("removeimage", image.id);

              this.$emit("changeimage", {
                imageId: this.images[0].id,
                description: this.images[0].imageDescr,
                url: this.images[0].imageURL,
              });

              localStorage.setItem(
                "imageStorage",
                JSON.stringify(this.allimages)
              );
              // location.reload(); //cheap fix that doesn't cause issues

              // console.log("IMAGES");
              // this.allimages.forEach((image, imgIndex, array) => {
              //   for (imageLocal of this.images)
              //     if (image.id > imageLocal.id) {
              //       console.log("ALL THEY KEEP");
              //       //making the most recent image the new one
              //       imageLocal.imageURL = image.imageUrl;
              //       imageLocal.imageDescr = image.imageDescr;

              //       this.$emit("removeimage", image.id); //removing the most recent image from the gallery
              //       // this.images = this.images.filter((i) => i != image);
              //       // this.removeReady = true;
              //       // this.$forceUpdate();

              //       // localStorage.setItem(
              //       //   "imageStorage",
              //       //   JSON.stringify(this.allimages)
              //       // );
              //       // imageLocal.mainImage = image.mainImage;
              //       // this.imageExists = true;
              //       // this.toShow = true;
              //       // this.showImage = true;
              //       // this.$emit("newborder", "has-image");
              //     }
              //   this.$emit("changeimage", {
              //     imageId: this.images[0].id,
              //     description: this.images[0].imageDescr,
              //     url: this.images[0].imageURL,
              //   }); //repurposing the changeimage event to change the imageUrl as well
              // });
              // localStorage.setItem(
              //   "imageStorage",
              //   JSON.stringify(this.allimages)
              // );
            } else {
              let deleteFirstImage = false;
              if (
                this.images[0].mainImage === true &&
                this.allimages.length <= 2
              ) {
                deleteFirstImage = true;
                //What I'm forgetting is that it might not save the image counter values

                //IT WORKS WITHOUT A REFRESH :D
              }

              for (image of this.images) {
                this.$emit("removeimage", image.id);
              }

              this.images = this.images.filter((i) => i != image);

              localStorage.setItem(
                "imageStorage",
                JSON.stringify(this.allimages)
              );

              // this.imageRemoved = true;

              if (deleteFirstImage === true) {
                // this.imageRemoved = false;
                window.location.reload();

                //while it does reload the page, I do have to consider: is it worth writing much more code that involves emitting events and including more variables to local storage, just to prevent the page from reloading? After all, this scenario will only occur if the user deletes the first image, without any others existing

                // this.$emit("newborder", undefined);
                // this.$emit("rerendercomponent");
                // this.$emit("refreshstorage");
                // imageStorage = 0;
                // this.$emit("resetstorage", undefined);
                // console.log("False");
              } else {
                this.imageRemoved = true;
              }
            }
            // this.imageRemoved = false;

            //look into deleting the component so it doesn't cause layout issues inside the section
            //id-- (but doesn't seem nesseccary or easy to implement)
            // this.allimages.filter((i) => i != image);
          }, //As a sidenote, since I only have one image for each component, I could have made my life much easier by having a simple image object instead of an array of objects. Might refactor this if it isn't too hard.
          editImage() {
            if (this.editing) {
              for (image of this.images) {
                this.$emit("changeimage", {
                  imageId: image.id,
                  description: image.imageDescr,
                });
              }
            }
            this.editing = !this.editing;
            this.$refs.editBtn[0].classList.toggle("edit-btn-active");
            this.$refs.editDescr[0].focus(); //implement it with nextTick once I carry it over to the file version of vue for the final extension
          },
          selectImage() {
            this.allimages.forEach((image, imgIndex, array) => {
              for (imageLocal of this.images) {
                if (image.mainImage === true) {
                  //saving the main image
                  let previousMainImageUrl = image.imageUrl;
                  let previousMainImageDescr = image.imageDescr;
                  console.log(`Previous main image: ${previousMainImageDescr}`);
                  console.log(`Selected image descr: ${imageLocal.imageDescr}`);
                  //Not as an object because there was an issue with it changing

                  //setting the main image to be the one we selected from the gallery
                  image.imageUrl = imageLocal.imageURL;
                  image.imageDescr = imageLocal.imageDescr;

                  // imageLocal.imageURL = previousMainImage.imageUrl;
                  // imageLocal.imageDescr = previousMainImage.imageDescr;

                  //Exchaning the images (giving the main one to the one we selected)
                  imageLocal.imageURL = previousMainImageUrl;
                  imageLocal.imageDescr = previousMainImageDescr;
                  console.log("ImageGal after" + imageLocal.imageDescr);
                  console.log("main image after" + previousMainImageDescr);

                  this.$emit("changeimage", {
                    imageId: imageLocal.id,
                    description: imageLocal.imageDescr,
                    url: imageLocal.imageURL,
                  });

                  localStorage.setItem(
                    "imageStorage",
                    JSON.stringify(this.allimages)
                  );
                }
              }
            });
          },
          // imgHovered() {
          //   this.$refs.mainImage[0].classList.add("main-image-hovered");
          // ends up flickering due to the individual buttons. Will have to rethink it @mouseover="imgHovered"},
          showBtn() {
            this.btnActive = "btn-container-active";
          },
          hideBtn() {
            this.btnActive = false;
          },

          //,
          // addImage() {
          //   this.$emit(
          //     "addImage",
          //     this.images.push(this.imageURL, this.imageDescr)
          //   );
          // },
        },

        watch: {
          // newImage: {
          //   handler() {
          //     if (
          //       this.newImage.url.match(/\.(jpeg|jpg|gif|png|svg)$/) != null
          //     ) {
          //       this.isValid = true;
          //       this.warnText = null;
          //     } else {
          //       this.isValid = false;
          //       this.warnText =
          //         "This is not a valid image URL. Please make sure you entered the right link.";
          //     }
          //     if (
          //       this.newImage.url != null &&
          //       this.newImage.descr != null &&
          //       this.isValid
          //     ) {
          //       this.toShow = true;
          //       this.imageReady = "add-image-ready";
          //     }
          //   },
          //   deep: true,
          // },
          // allimages: {
          //   handler() {
          //     this.allimages.forEach((image, imgIndex, array) => {
          //       for (imageLocal of this.images)
          //         if (image.id === imageLocal.id && this.removeReady === true) {
          //           console.log("watched");
          //           this.imageRemoved = true;
          //         }
          //     });
          //   },
          //   deep: true,
          // },
          allimages: {
            handler() {
              this.allimages.forEach((image, imgIndex, array) => {
                for (imageLocal of this.images) {
                  if (
                    image.id === imageLocal.id &&
                    imageLocal.mainImage === true
                  ) {
                    //When a different image gets selected, the main image gets updated immediately
                    imageLocal.imageURL = image.imageUrl;
                    imageLocal.imageDescr = image.imageDescr;
                    console.log("Watched!!!");
                  }
                  // if(image.id === imageLocal.id && image.Local.mainImage === false &&)
                  // if (this.latestImage != undefined) {
                  //   this.allimages.forEach((image) => {
                  //     if (image.id === this.latestImage.id) {
                  //       this.imageRemoved = true;
                  //       console.log("latest image" + this.latestImage);
                  //     }
                  //   });
                  // }
                  //This only works once each time
                  if (imageLocal.imageURL) {
                    //IT WORKS!!!!!!!!!!
                    let exists = array.find(
                      (element) => element.id === imageLocal.id
                    );
                    // console.log("Exists:" + exists);

                    if (!exists) {
                      this.imageRemoved = true;
                      // this.images = this.images.filter((i) => i != image);
                      // this.$emit("removeimage", image.id);
                      console.log("Exists:" + exists);
                      console.log(
                        "Image to delete (descr):" + imageLocal.imageDescr
                      );
                    }
                  }
                }
              });
            },
            deep: true,
          },
          // latestImage: {
          //   handler() {
          //     this.allimages.forEach((image, imgIndex, array) => {
          //       if (
          //         this.latestImage != undefined &&
          //         this.images[0].id === this.latestImage.id
          //       ) {
          //         console.log("this works");
          //         this.imageRemoved = true;
          //       }
          //     });
          //   },
          //   deep: true,
          // },
          images: {
            handler() {
              //checks whether the url given is valid every time the imageURL property changes
              //bug when description is typed first
              for (image of this.images) {
                // if (!this.showImage) {
                let currentUrl = undefined;
                // if (
                //   image.imageURL.match(/\.(jpeg|jpg|gif|png|svg|webp)$/) != null
                // )
                // let validUrl = undefined;
                if (
                  image.imageURL != "" &&
                  !this.showImage &&
                  image.imageURL != this.previousURL
                ) {
                  //otherwise the function would run while editing the description, or while typing it out for the first time. This would happen because the checkURL() function is inside the image watcher, which fires whenever any part of the image object changes, not just it's description
                  async function checkURL() {
                    return new Promise((resolve, reject) => {
                      const imageToLoad = new Image();
                      imageToLoad.src = image.imageURL;
                      imageToLoad.onload = () => (
                        (this.validUrl = true),
                        console.log(`valid url ${this.validUrl}`),
                        resolve(true)
                      );
                      imageToLoad.onerror = () => (
                        (this.validUrl = false),
                        console.log(`valid url ${this.validUrl}`),
                        resolve(false)
                      );
                    });
                  }
                  // if (this.validUrl) {
                  //   // return true;
                  //   return new Promise((resolve) => resolve(true));
                  // } else {
                  //   // return false;
                  //   return new Promise((reject) => reject(false));
                  // }

                  // async function checkURL() {
                  //   const imageToLoad = new Image();
                  //   imageToLoad.src = image.imageURL;
                  //   imageToLoad.onload = await (() => {
                  //     this.validUrl = true;
                  //     return new Promise((resolve) => resolve(true));
                  //     // console.log(`valid url ${this.validUrl}`);
                  //   });
                  // }
                  // checkURL();
                  //
                  //   // "This is not a valid image URL. Please make sure you entered the right link.";
                  // });
                  console.log(checkURL());
                  checkURL().then((resolve, reject) => {
                    console.log(resolve + "resolve");
                    this.previousURL = image.imageURL;
                    console.log(this.previousURL + " previousURL");
                    console.log(image.imageDescr + "Descr");
                    if (resolve) {
                      console.log("VALID");
                      this.isValid = true;
                      this.warnText = null;
                    } else {
                      this.isValid = false;
                      this.warnText = "Invalid URL";
                    }
                  });
                  // if (checkURL()) {
                  //   this.isValid = true;
                  //   this.warnText = null;
                  // } else {
                  //   this.isValid = false;
                  //   this.warnText = "Invalid URL";
                  // }
                }

                // if (
                //   image.imageDescr &&
                //   !this.showImage //&&
                //   // this.$refs.inputDescr[0].classList.contains(
                //   //   "add-image-url-error"
                //   // )
                // ) {
                //   this.$refs.inputDescr[0].classList.remove(
                //     "add-image-url-error"
                //   );
                // }

                if (
                  image.imageURL != "" &&
                  image.imageDescr != "" &&
                  image.imageDescr != undefined &&
                  this.isValid
                ) {
                  this.toShow = true;
                  this.imageReady = "add-image-ready";
                  currentUrl = image.imageURL;
                  // this.newUrl = image.imageURL;
                  // this.newDescr = image.imageDescr;
                } else {
                  this.toShow = false;
                  this.imageReady = null;
                  currentUrl = null;
                }

                if (
                  image.imageUrl != currentUrl &&
                  this.showImage === true &&
                  this.imageRemoved === false &&
                  this.editing === false
                ) {
                  //Update: We have to make sure that the user isn't editing the description, because otherwise the animation would play after each keystroke

                  //play slide in animation when the user selects a different image
                  this.$refs.outerImageWrapper.style.opacity = "0";
                  this.showImage = false;
                  this.imageRemoved = true;
                  this.$emit("newborder", "has-image-animation");
                  setTimeout(() => {
                    this.initialLoad = "none";
                    this.imageRemoved = false;
                  }, 0);
                  setTimeout(() => {
                    this.$emit("newborder", "has-image");
                    this.initialLoad = "block";
                    this.$refs.outerImageWrapper.style.opacity = "1";
                    this.showImage = true;
                  }, 1);
                }

                //I need to tell it when to run
                // let exists = this.allimages.find(
                //   (element) => element.id === image.id
                // );
                // console.log("Exists:" + exists);
                // // if (image.imageURL != null) {
                // // }

                // if (!exists && this.showImage === true) {
                //   this.imageRemoved = true;
                //   console.log("Exists:" + exists);
                // }
              }
            },
            deep: true,
          },
        },
      });

      app.component("image-gallery", {
        template: `
                  <Transition name="section-fade">
                    <div v-if="allimages.length > 1" >
                      <hr/>
                      <section class="image-gallery" >
                        <add-image :allimages="allimages" :imagecounter="imagecounter" @removeimage="removeImageBubbleUp" @changeimage="changeImageBubbleUp" @newimage="" v-for="image in imagecounter" :key="image"/>
                      </section>
                    </div>
                  </Transition>`,

        // <add-image :allimages="allimages" :imagecounter="imagecounter" @removeimage="removeImageBubbleUp" @changeimage="changeImageBubbleUp" @newimage="deleteUndefinedBubbleUp" v-for="image in this.imagecounter.length"/>

        // v-for="image in allimages.length - 1"
        // v-if="images.length > 1"
        // <div class="add-image" v-if="isValid">
        // <p>{{cart.carrot}}</p>
        // <add-image :allimages="allimages" @removeimage="removeImageBubbleUp" @changeimage="changeImageBubbleUp" v-if="allimages.length > 3"/>
        // v-for="image in allimages.length - 1" it works!
        props: ["allimages", "cart", "imagecounter"],
        components: ["add-image"],
        methods: {
          removeImageBubbleUp(imageToDelete) {
            //bubbling up the event to the parent
            this.$emit("removeimage", imageToDelete);
          },
          changeImageBubbleUp(data) {
            this.$emit("changeimage", data);
          },
        },
        data() {
          return {
            images: 0,
            key: 0,
          };
        },
        computed: {
          // imageLength() {
          //   this.images = this.allimages.length;
          // },
          reversedArray() {
            return this.imagecounter.slice().reverse();
          },
        },
        created() {},
        // computed: {
        //   isValid {
        //     get() {
        //       return this.isValid
        //     }
        //   }
        // }
      });

      app.mount("#app");
    </script>
  </body>
</html>
